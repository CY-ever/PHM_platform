
## the code was designed to model the defect depth generated by ball defect
# author: Diwang Ruan
# date: 2020.09.09
# version: V1.0

## introduction of "ball_defect"
# the functon was used to model the defect depth generated by ball defect
# if defect generates on the all, then it will strike the rings twice during one revolution
# the curvatures of the inner ring and outer ring are different, therefore,the defect depthes caused by the same defect are different on the inner/outer rings
# input:
# Di: ball diameter, m
# Do: length of defect, m
# d: width of defect, m
# B: hight of defect, m
# phi_s ��defect depth at present position, m
# delta_phi_d: the span angle of defect, rad;
# phi_start: the start position of defect, rad;
# output: defect_depth, m��

# the modeling idea comes from paper: "ball bearings defect models: a study of simulated and experimental fault signatures"

## depth calculation for ball defect

# function
import numpy as np
from numpy import ravel


def ball_defect(Di, Do, d, B, phi_s, delta_phi_d, phi_start, ):
    # varargin = ball_defect.varargin
    # nargin = ball_defect.nargin

    # the angular width of ball fault in terms of inner and outer races
    phi_bi = np.dot(delta_phi_d, d) / Di
    phi_bo = np.dot(delta_phi_d, d) / Do
    x = B / 2
    Cdo = np.dot(1 / 2, Do) - np.sqrt((Do / 2) ** 2 - x ** 2)
    Cdr = d / 2 - np.sqrt((d / 2) ** 2 - x ** 2)

    if all(ravel(phi_s) > ravel(phi_start)) and all(ravel(phi_s) < (phi_start + phi_bo)):
        H_ball = Cdr - Cdo

    else:
        if all(ravel(phi_s) > (phi_start + np.pi)) and all(ravel(phi_s) < (phi_start + np.pi + phi_bi)):
            H_ball = Cdr + Cdo

        else:
            H_ball = 0



    defect_depth = np.copy(H_ball)
    # print(defect_depth)
    return defect_depth


if __name__ == '__main__':
    # ball_defect(12, 23, 2, 23, 32, 4, 5)
    pass
