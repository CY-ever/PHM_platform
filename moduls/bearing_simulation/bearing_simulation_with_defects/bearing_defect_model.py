# bearing_defect_model.m

## the code was designed to model the bearing defect, including defect position, defect size, and defect shape.
# author: Diwang Ruan
# date: 2020.09.09
# version: V1.0

## introduction of "bearing_defect_model"
# the contacting force of every ball in " bearing_dynamics_model" was
# calculated by deformation, and the deformation will be modified by defects.
# when calculating the contacting force for a ball, "
# bearing_dynamics_model" will call "bearing_defect_model" to check whether
# there is deformation modification and return the defect_depth value if the present ball encounters a defect.

# inputs: ball_theta, ball_number,sim_time
# ball_theta: the angular position of the present ball, rad.
# ball_number: the present ball flag to be calculated, from 1 to Nb.
# sim_time: the present simulation time/clock, s;
# output: defect_depth, radial deformation modificationm generated by defect depth, m;

# the modeling idea comes from paper: "dynamics modeling and analysis of local fault of rolling element bearing"

##  revision info:
# the fault depth has been modeled as a constant without considering fault shape
# line 81 and 100 has been replaced by line 82 and 101 respectively;

## code of the defect model

import numpy as np
from moduls.bearing_simulation.bearing_simulation_with_defects.ball_defect import ball_defect
from moduls.bearing_simulation.bearing_simulation_with_defects.GlobalVariable import globalVariables as gbv


# @function
def bearing_defect_model(ball_theta=None, ball_number=None, sim_time=None, *args, **kwargs):
    # varargin = bearing_defect_model.varargin
    # nargin = bearing_defect_model.nargin

    # # to read in the necessary parameters from workspace
    # bearing_parameter = evalin('base', 'bearing_parameter')
    # condition_parameter = evalin('base', 'condition_parameter')
    # defect_parameter = evalin('base', 'defect_parameter')
    bearing_parameter = gbv.bearing_parameter
    condition_parameter = gbv.condition_parameter
    defect_parameter = gbv.defect_parameter

    Di = bearing_parameter.Di
    Do = bearing_parameter.Do
    Dm = bearing_parameter.Dm
    d = bearing_parameter.d

    contact_angle = np.deg2rad(bearing_parameter.contact_angle)
    omega_shaft = np.dot(np.dot(2, np.pi), condition_parameter.omega_shaft)

    # to obtain the number of defects for every defect type
    # num_outer_defect = defect_parameter.outer_ring_number(1)
    # num_inner_defect = defect_parameter.inner_ring_number(1)
    # num_ball_defect = defect_parameter.ball_number(1)
    num_outer_defect = defect_parameter.outer_ring_number
    num_inner_defect = defect_parameter.inner_ring_number
    num_ball_defect = defect_parameter.ball_number
    # to get the initial angular positions for every defect type
    init_position_outer_defect = np.deg2rad(defect_parameter.outer_ring_local_position)
    init_position_inner_defect = np.deg2rad(defect_parameter.inner_ring_local_position)
    init_position_ball_defect = np.deg2rad(defect_parameter.ball_local_position)
    # to collect the whole size parameters defining all the defects in every defect type
    size_outer_defect = defect_parameter.outer_ring_size
    size_inner_defect = defect_parameter.inner_ring_size
    size_ball_defect = defect_parameter.ball_size
    # to calculate the defect spaning angle for all the defects under every defect type
    # delta_phi_d_outer=2*asin(size_outer_defect(:,2)/(Dm+d));
    # delta_phi_d_inner=2*asin(size_inner_defect(:,2)/Di);
    # delta_phi_d_ball=2*asin(size_ball_defect(:,2)/d);

    delta_phi_d_outer = np.dot(np.dot(1 / 360, 2), np.pi)
    delta_phi_d_inner = np.dot(np.dot(1 / 360, 2), np.pi)
    delta_phi_d_ball = np.dot(np.dot(1 / 360, 2), np.pi)

    # calculation of Cd under outer defect
    cd_outer = 0
    # bearing_defect_model.m:71
    if defect_parameter.outer_ring_switch == 1:
        # for i in np.arange(1, num_outer_defect).reshape(-1):
        for i in range(0, num_outer_defect):
            if ball_theta > init_position_outer_defect[0, i] and ball_theta <(
                    init_position_outer_defect[0, i] + delta_phi_d_outer):
                delta_phi_d_temp = delta_phi_d_outer
                L_temp = size_outer_defect[0]
                B_temp = size_outer_defect[1]
                H_temp = size_outer_defect[2]

                Hd_temp = np.dot(0.5, d) - np.sqrt(
                    np.dot((np.dot(0.5, d)), (np.dot(0.5, d))) - np.dot((np.dot(0.5, B_temp)), (np.dot(0.5, B_temp))))
                # bearing_defect_model.m:79
                phi_start = init_position_outer_defect[0, i]
                # bearing_defect_model.m:80
                #             cd_outer=defect_shape(d,L_temp,B_temp,H_temp,Hd_temp,ball_theta,phi_start,delta_phi_d_temp);
                cd_outer = min(H_temp, Hd_temp)
    # bearing_defect_model.m:82

    # calculation of Cd under inner defect
    cd_inner = 0
    # bearing_defect_model.m:89
    if defect_parameter.inner_ring_switch == 1:
        # for i in np.arange(1, num_inner_defect).reshape(-1):
        for i in range(0, num_inner_defect):
            # the following formulation has been corrected compared with V1.0
            if np.mod(init_position_inner_defect[0, i] + np.dot(omega_shaft, sim_time),
                      np.dot(2, np.pi)) < ball_theta < np.mod(init_position_inner_defect[0, i] +
                                                              delta_phi_d_inner + np.dot(omega_shaft, sim_time),
                                                              np.dot(2, np.pi)):
                delta_phi_d_temp = delta_phi_d_inner
                L_temp = size_inner_defect[0]
                B_temp = size_inner_defect[1]
                H_temp = size_inner_defect[2]

                Hd_temp = np.dot(0.5, d) - np.sqrt(
                    np.dot((np.dot(0.5, d)), (np.dot(0.5, d))) - np.dot((np.dot(0.5, B_temp)), (np.dot(0.5, B_temp))))
                # bearing_defect_model.m:98
                phi_start = init_position_inner_defect[0, i]
                # bearing_defect_model.m:99
                #            cd_inner=defect_shape(d,L_temp,B_temp,H_temp,Hd_temp,ball_theta,phi_start,delta_phi_d_temp);
                cd_inner = min(H_temp, Hd_temp)
    # bearing_defect_model.m:101

    # calculation of Cd under ball defect
    cd_ball = 0
    # bearing_defect_model.m:108
    if defect_parameter.ball_switch == 1:
        # for i in np.arange(1, num_ball_defect).reshape(-1):
        for i in range(0, num_ball_defect):
            if ball_number == defect_parameter.ball_fault_ball_identifier[0, i]:
            # if ball_number == defect_parameter.ball_fault_ball_identifier:
                B_temp = size_ball_defect[1]
                # bearing_defect_model.m:112
                phi_s = np.mod(np.dot(np.dot(np.dot(omega_shaft, Dm) / d, (1 - (np.dot(d / Dm, np.cos(contact_angle))) ** 2)), sim_time),
                            np.dot(2, np.pi))
                # bearing_defect_model.m:113
                phi_start = init_position_ball_defect[0, i]
                # bearing_defect_model.m:114
                cd_ball = ball_defect(Di, Do, d, B_temp, phi_s, delta_phi_d_ball, phi_start)
    # bearing_defect_model.m:115

    # calculation of final cd
    cd_final = cd_outer + cd_inner + cd_ball
    # bearing_defect_model.m:121
    defect_depth = cd_final
    # bearing_defect_model.m:122
    return defect_depth


if __name__ == '__main__':
    pass
