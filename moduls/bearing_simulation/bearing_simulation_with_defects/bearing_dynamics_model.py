
## the code was designed to model the 5-DoF bearing dynamics.


## version modification infos:
# version: V2.0
# reviser:  Diwang Ruan
# date: 2020.09.30
# revision points:
# to add a formulation to calculate the cage speed;
# formulation for delta_geometry has been corrected: cos(ball_position) and sin(ball_position) have been replaced by cos(theta) and sin(theta);
# "ball_position" in formulation of fx and fy has been replaced by "theta".

## introduction of "bearing_dynamics_model"
# the modeling idea is to regard the inner-ring, outer-ring, balls as mass-stiffness-damper unit
# to model the three parts based on Newton's second law with differential equations
# besides normal beairng model based on 5-DoF, it calls "bearing_defect_model" to calculate the depth generated by defects under different positions and sizes
# input: time, and x
# output: x'
# x is a [1,10] array, elements are defined as: xs, xs',ys, ys',xp, xp', yp, yp',yb, yb'


import numpy as np
import scipy

from moduls.bearing_simulation.bearing_simulation_with_defects.bearing_defect_model import bearing_defect_model
from moduls.bearing_simulation.bearing_simulation_with_defects.GlobalVariable import globalVariables as gbv


# @function
def bearing_dynamics_model(x=None, t=None, *args, **kwargs):
    # varargin = bearing_dynamics_model.varargin
    # nargin = bearing_dynamics_model.nargin



    bearing_parameter = gbv.bearing_parameter
    pedestal_parameter = gbv.pedestal_parameter
    shaft_parameter = gbv.shaft_parameter
    sprung_parameter = gbv.sprung_parameter
    condition_parameter = gbv.condition_parameter
    DoF5_parameter = gbv.DoF5_parameter
    sim_parameter = gbv.sim_parameter

    # if t<sim_parameter.step_size
    #     data_size=(sim_parameter.sim_duration/sim_parameter.step_size)+1;
    #     defect_state=zeros(data_size,2);
    # end

    # parameters of the ball
    Kb = bearing_parameter.Kb

    d = bearing_parameter.d

    Dm = bearing_parameter.Dm

    Nb = bearing_parameter.Nb

    Di = bearing_parameter.Di

    Do = bearing_parameter.Do

    contact_angle = bearing_parameter.contact_angle

    # parameters of the pedestal
    Mp = pedestal_parameter.Mp

    Kp = pedestal_parameter.Kp

    Cp = pedestal_parameter.Cp

    # parameters of the shaft
    Ms = shaft_parameter.Ms

    Ks = shaft_parameter.Ks

    Cs = shaft_parameter.Cs

    # parameters of the sprung mass system
    Mr = sprung_parameter.Mr

    Kr = sprung_parameter.Kr

    Cr = sprung_parameter.Cr

    # parameters of working condition
    Fr = condition_parameter.Fr

    Fa = condition_parameter.Fa

    omega_s = (2 * np.pi) * condition_parameter.omega_shaft

    omega_cage = (omega_s * (1 - ((d / Dm) * np.cos(np.deg2rad(contact_angle))))) / 2

    g = condition_parameter.g
    # parameters specially for 5-DoF model
    phi_slip = DoF5_parameter.mutation_percentage

    phi_0 = DoF5_parameter.initial_angular_position

    fx = 0
    fy = 0
    # dx = np.zeros((10, 1))
    dx = np.zeros(10)

    for k in range(0, Nb):
        random_percentage = scipy.rand()
        load_factor = - 1
        # ball_position = ((2 * np.pi) / Nb) * (k - 1)
        ball_position = ((2 * np.pi) / Nb) * k
        theta_raw = np.mod(ball_position + np.dot(omega_cage, t) + phi_0, 2 * np.pi)
        if np.pi / 2 < theta_raw.all() < np.dot(3, np.pi) / 2:
            load_factor = 1

        theta = np.mod(
            ball_position + np.dot(omega_cage, t) + phi_0 + np.dot(np.dot(np.dot(load_factor, random_percentage), 0.5),
                                                                   phi_slip),
            np.dot(2, np.pi))

        delta_defect = bearing_defect_model(theta, k, t)

        # delta_geometry = (x[0] - x[4]) * np.cos(theta) + (x[2] - x[6]) * np.sin(theta)
        delta_geometry = np.dot((x[0] - x[4]),  np.cos(theta)) + np.dot((x[2] - x[6]), np.sin(theta))

        delta_r = delta_geometry - delta_defect

        if delta_r > 0:
        # if delta_r.all() > 0:
            # fx = fx + np.dot(np.dot(Kb, delta_r ** 1.5), np.cos(theta))
            # fy = fy + np.dot(np.dot(Kb, delta_r ** 1.5), np.sin(theta))
            fx = fx + (Kb * (delta_r ** 1.5)) * np.cos(theta)
            fy = fy + (Kb * (delta_r ** 1.5)) * np.sin(theta)

    # main body of the 5 DoF dynamics model, described by 10 differential equations
    # dx[0] = x[1]
    # dx[1] = (Fa - fx - np.dot(Ks, x[0]) - np.dot(Cs, x[1])) / Ms
    # dx[2] = x[3]
    # dx[3] = (Fr - np.dot(Ms, g) - fy - np.dot(Ks, x[2]) - np.dot(Cs, x[3])) / Ms
    # dx[4] = x[5]
    # dx[5] = (fx - np.dot(Kp, x[4]) - np.dot(Cp, x[5])) / Mp
    # dx[6] = x[7]
    # dx[7] = (np.dot(- Mp, g) + fy + np.dot(Cr, x[9]) + np.dot(Kr, x[8]) - np.dot((Kp + Kr), x[6]) - np.dot((Cp + Cr),
    #                                                                                                        x[7])) / Mp
    # dx[8] = x[9]
    # dx[9] = (np.dot(- Mr, g) - np.dot(Kr, (x[8] - x[6])) - np.dot(Cr, (x[9] - x[7]))) / Mr
    dx[0] = x[1]
    dx[1] = (Fa - fx - (Ks * x[0]) - (Cs * x[1])) / Ms
    dx[2] = x[3]
    dx[3] = (Fr - (Ms * g) - fy - (Ks * x[2]) - (Cs * x[3])) / Ms
    dx[4] = x[5]
    dx[5] = (fx - (Kp * x[4]) - (Cp * x[5])) / Mp
    dx[6] = x[7]
    dx[7] = ((- Mp * g) + fy + (Cr * x[9]) + (Kr * x[8]) - ((Kp + Kr) * x[6]) - ((Cp + Cr) * x[7])) / Mp
    dx[8] = x[9]
    dx[9] = ((- Mr * g) - (Kr * (x[8] - x[6])) - (Cr * (x[9] - x[7]))) / Mr
    # dx = dx.reshape((10, 1))
    return dx


if __name__ == '__main__':
    pass
