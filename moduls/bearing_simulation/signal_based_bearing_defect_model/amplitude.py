## this code was developed to model the acceleration amplitude under different defect type
# author: Diwang Ruan
# date: 2020.09.17
# version: V1.0

## introduction of "amplitude"
# function: to simulate the acceleration amplitude produced by external radial load, here regardless of the decay process.
# input:
# sim_time: current simulation clock, -s;
# bearing_parameter: structure for bearing definition, defined in "bearing_defect_simulation.m";
# defect_parameter: structure for defect definition, defined in "bearing_defect_simulation.m"
# condition_parameter: structure for condition definition, defined in "bearing_defect_simulation.m"
# output:
# Am: the amplitude of acceleration generated by load at current time, a signle value at every sim_time.


## additional infos:
# reference: paper-" vibration model of rolling element bearings in a rotor-bearing systems for fault diagnosis"
# comments: 
# in this paper, the load was modeled as a sum of two parts: determinate load and alternate load.
# different from the paper, in this script, the load was modeled as only on parameter load_max, but the load distribution was also considered


## the main code of "amplitude"

import numpy as np


def amplitude(sim_time=None, bearing_parameter=None, condition_parameter=None, defect_parameter=None, *args, **kwargs):
    # varargin = amplitude.varargin
    # nargin = amplitude.nargin

    global Am
    D = bearing_parameter.D
    d = bearing_parameter.d
    alpha = np.deg2rad(bearing_parameter.contact_angle)
    load_max = condition_parameter.load_max
    load_proportional_factor = condition_parameter.load_proportional_factor
    fs = condition_parameter.shaft_speed

    defect_init = np.deg2rad(defect_parameter.defect_initial_position)

    defect_type = defect_parameter.defect_type

    phi_limit = np.deg2rad(condition_parameter.phi_limit)

    load_distribution_factor = condition_parameter.load_distribution_parameter

    bearing_type_factor = bearing_parameter.bearing_type_factor

    # calculation of necessary parameters, demanding for further consideration !
    omega_inner = np.dot(np.dot(fs, 2), np.pi)

    omega_cage = np.dot(np.dot(np.dot(2, np.pi), fs) / 2, (1 - np.dot(D / d, np.cos(alpha))))

    # acc load under outer ring defect
    if defect_type == 0:
        phi = np.copy(defect_init)

        if (phi >= 0 and phi <= phi_limit) or (phi >= np.dot(2, np.pi) - phi_limit and phi <= np.dot(2, np.pi)):
            Am = np.dot(np.dot(load_max, load_proportional_factor),
                        (1 - np.dot(1 / (np.dot(2, load_distribution_factor)),
                                    (1 - np.cos(phi)))) ** bearing_type_factor)

        else:
            Am = 0

    # acc load under inner ring defect
    if defect_type == 1:
        phi = np.mod(defect_init + np.dot(omega_inner, sim_time), np.dot(2, np.pi))

        if (phi >= 0 and phi <= phi_limit) or (phi >= np.dot(2, np.pi) - phi_limit and phi <= np.dot(2, np.pi)):
            middle = 1 - np.dot(1 / (np.dot(2, load_distribution_factor)), (1 - np.cos(phi)))
            if (middle >= 0):
                Am = np.dot(np.dot(load_max, load_proportional_factor), middle ** bearing_type_factor)

            else:
                middle = -middle
                Am = np.dot(np.dot(load_max, load_proportional_factor), -middle ** bearing_type_factor)

            # Am = np.dot(np.dot(load_max, load_proportional_factor),
            #             (1 - np.dot(1 / (np.dot(2, load_distribution_factor)),
            #                         (1 - np.cos(phi)))) ** bearing_type_factor)

        else:
            Am = 0

    # acc load under ball defect
    if defect_type == 2:
        phi = np.mod(defect_init + np.dot(omega_cage, sim_time), np.dot(2, np.pi))

        if (phi >= 0 and phi <= phi_limit) or (phi >= np.dot(2, np.pi) - phi_limit and phi <= np.dot(2, np.pi)):

            middle = 1 - np.dot(1 / (np.dot(2, load_distribution_factor)), (1 - np.cos(phi)))
            if (middle >= 0):
                Am = np.dot(np.dot(load_max, load_proportional_factor), middle ** bearing_type_factor)

            else:
                middle = -middle
                Am = np.dot(np.dot(load_max, load_proportional_factor), -middle ** bearing_type_factor)

            # Am = np.dot(np.dot(load_max, load_proportional_factor),
            #             (1 - np.dot(1 / (np.dot(2, load_distribution_factor)),
            #                         (1 - np.cos(phi)))) ** bearing_type_factor)

        else:
            Am = 0

    return Am


if __name__ == '__main__':
    pass
