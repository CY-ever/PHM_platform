# -*- coding: utf-8 -*-
"""RF_GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VAzjOm-0z5Rh6SYq5dTWUsAacQKaiS8b
"""

# from google.colab import drive
# drive.mount('/content/drive')

import tensorflow as tf
import pandas as pd
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np
from random import choice
from keras.utils.np_utils import to_categorical
from sklearn.model_selection import train_test_split
import sys
import os

os.chdir('drive/MyDrive/2020WS/GA/')
sys.path.append('drive/MyDrive/2020WS/GA/')

# pip install import-ipynb

# import import_ipynb
import RandomForest


class Param:
    n_estimators = 10
    criterion = 'gini'
    max_depth = None
    min_samples_split = 2
    min_samples_leaf = 1
    min_weight_fraction_leaf = 0.0
    max_features = 'auto'
    max_leaf_nodes = None
    min_impurity_decrease = 0.0
    min_impurity_split = None
    bootstrap = True
    oob_score = False
    n_jobs = None
    random_state = None
    verbose = 0
    warm_start = False
    class_weight = None
    ccp_alpha = 0
    max_samples = None


class Option:
    sample_weight = None
    check_input = True
    X_idx_sorted = None


# Roulette Selection
def select(pop, fitness, POP_SIZE):
    idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=fitness / fitness.sum())
    return pop[idx]


# cross
def crossover(parent, pop, CROSS_RATE, POP_SIZE, DNA_SIZE, selection):
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE, size=1)  # Randomly take the index of a gene
        cross_points = np.random.randint(0, 2, size=DNA_SIZE).astype(np.bool)  # Randomly pick intersection
        for i, point in enumerate(cross_points):
            parent[cross_points] = pop[i_, cross_points]  # Random point crossover

    return parent


# mutations
def mutate(child, DNA_SIZE, MUTATION_RATE, selection):
    for point in range(DNA_SIZE):
        if np.random.rand() < MUTATION_RATE:

            if point == 0:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(4, 20)
            if point == 1:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(1, 12, size=1).tolist()[0]
            if point == 2:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(8, 30, size=1).tolist()[0]
    return child


def get_fitness(results, path, typ, savePath):
    Param1 = Param()
    Param1.random_state = 30
    Param1.n_estimators = results[2]
    Param1.max_path = results[0]
    Param1.min_samples_leaf = results[1]
    Option1 = Option()
    RandomForest.runAll(path, typ, Param1, Option1, savePath)
    score = RandomForest.fun_score(savePath, path)
    return score


def create_initial_data(selection, path, typ, savePath):  # data is x_train,y_train,x_value,y_value
    pop_size = selection[
        6]  # pop_size is the number of for loops, indicating how many sets of data to be generated
    pop = np.empty([pop_size, 3], dtype=object)  # pop contains all the parameters to be optimized
    fitness = np.zeros([pop_size, ])  # fitness contains accuracy of LSTM model
    for i in range(0, pop_size):
        results = []
        max_depth = 0
        if selection[0] == selection[1]:
            max_depth = selection[0]
        else:
            max_depth = np.random.randint(selection[0], selection[1], size=1).tolist()[0]

        max_leaf_nodes = 0
        if selection[2] == selection[3]:
            max_leaf_nodes = selection[2]
        else:
            max_leaf_nodes = np.random.randint(selection[2], selection[3], size=1).tolist()[0]
        n_estimators = 0
        if selection[4] == selection[5]:
            n_estimators = selection[4]
        else:
            n_estimators = np.random.randint(selection[4], selection[5], size=1).tolist()[0]

        results.append(max_depth)
        results.append(max_leaf_nodes)
        results.append(n_estimators)
        print(results)
        pop[i] = results

        fitness[i] = get_fitness(results, path, typ, savePath)
        print('第' + str(i + 1) + '个DNA')
    return pop, fitness


def fitness_figure(best_generation):
    x = np.linspace(1, len(best_generation), len(best_generation))
    y = best_generation
    plt.plot(x, y)
    plt.xlabel("generation")
    plt.ylabel("fitness")
    plt.show()


def run(dna_size, pop_size, cross_rate, mutation_rate, n_generations, selection, path, typ, savePath, threshold):
    DNA_SIZE = dna_size
    POP_SIZE = pop_size
    CROSS_RATE = cross_rate
    MUTATION_RATE = mutation_rate
    N_GENERATIONS = n_generations

    ret = create_initial_data(selection, path, typ, savePath)
    pop = ret[0]
    fitness = ret[1]
    original_pop = pop
    original_finess = fitness
    print(pop)
    print(fitness)
    fitness = fitness.reshape(POP_SIZE, )

    MAX_Index = np.argmax(fitness)  # Find the best fitness of the initial population
    MAX_DNA = pop[MAX_Index, :]

    best_generation = []

    flag = 0
    dna_set = []
    for each_generation in range(N_GENERATIONS):

        pop = select(pop, fitness, POP_SIZE)  # select
        pop_copy = pop.copy()
        for parent in pop:
            child = crossover(parent, pop, CROSS_RATE, POP_SIZE, DNA_SIZE, selection)  # cross
            child = mutate(child, DNA_SIZE, MUTATION_RATE, selection)  # mulation
            parent = child

        if fitness[0] <= fitness[
            MAX_Index]:  # If the fitness of the first DNA is smaller than the maximum, then MAX_DNA is placed first
            pop[0] = MAX_DNA

        fitness = np.zeros([POP_SIZE, ])
        for i in range(POP_SIZE):
            pop_list = list(pop[i])
            fitness[i] = get_fitness(pop_list, path, typ, savePath)
            print('第%d代第%d个染色体的适应度为%f' % (each_generation + 1, i + 1, fitness[i]))
            print('此染色体为：', pop_list)
            if fitness[i] >= threshold:
                flag = 1
                print("条件终止")
                break;
        print("Generation:", each_generation + 1, "Most fitted DNA: ", pop[np.argmax(fitness), :], "适应度为：",
              fitness[np.argmax(fitness)])
        MAX_Index = np.argmax(fitness)
        MAX_DNA = pop[MAX_Index, :]
        dna_set.append(MAX_DNA)
        best_generation.append(fitness[MAX_Index])
        if flag == 1:
            break
    return best_generation, dna_set, original_pop, original_finess


if __name__ == '__main__':

    # ===================test=======================

    path1='/content/drive/MyDrive/2020WS/GA/traindata.csv'
    path2='/content/drive/MyDrive/2020WS/GA/trainlabel.csv'
    save_path='/content/drive/MyDrive/2020WS/GA/test3.pkl'
    selection = [4, 20, 1, 12, 8, 30, 5]
    threshold = 0.95
    best_generation, dna_set, original_pop, original_finess = run(3, 5, 0.5, 0.5, 7, selection, [path1, path2],
                                                                  "RandomForestClassifier", save_path, threshold)
    print(best_generation)
    print(dna_set)
    print(original_pop)
    print(original_finess)

    fitness_figure(best_generation)
