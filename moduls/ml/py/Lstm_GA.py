# -*- coding: utf-8 -*-
"""Lstm_GA.ipynb（2）

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s16u-TqC-4wMFouW1wXhLbtfaxNmbEU_
"""

# from google.colab import drive

# drive.mount('/content/drive')

import tensorflow as tf
import pandas as pd
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np
from random import choice
from keras.utils.np_utils import to_categorical
from sklearn.model_selection import train_test_split
import sys
import os

os.chdir('drive/MyDrive/2020WS/GA/')
sys.path.append('drive/MyDrive/2020WS/GA/')

# pip install import-ipynb

# import import_ipynb
import Lstm


# Roulette Selection
def select(pop, fitness, POP_SIZE):
    idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=fitness / fitness.sum())
    return pop[idx]


# cross
def crossover(parent, pop, CROSS_RATE, POP_SIZE, DNA_SIZE, selection):
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE, size=1)  # Randomly take the index of a gene
        cross_points = np.random.randint(0, 2, size=DNA_SIZE).astype(np.bool)  # Randomly pick intersection
        for i, point in enumerate(cross_points):
            if i < 7:
                if selection[2 * i] != selection[
                    2 * i + 1]:  # If the user does not have a given value, proceed to the following steps
                    if point == True and pop[i_, i] * parent[
                        i] == 0:  # The gene at this position on any chromosome is 0
                        cross_points[i] = False  # cancel the exchange of this position
                    if point == True and i < 1:  # The gene to be exchanged is about the number of layers, cancel the exchange of this position
                        cross_points[i] = False
        parent[cross_points] = pop[i_, cross_points]  # Random point crossover

    return parent


# mutations
def mutate(child, DNA_SIZE, MUTATION_RATE, selection):
    for point in range(DNA_SIZE):
        if np.random.rand() < MUTATION_RATE:
            if point >= 1 and point <= 3:
                if child[point] != 0:
                    if selection[2 * point] != selection[2 * point + 1]:
                        child[point] = np.random.randint(32, 257, size=1).tolist()[0]
            if point == 4:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = choice([0, 0.1, 0.2])
            if point == 5:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(10, 21, size=1).tolist()[0]
            if point == 6:
                if selection[2 * point] != selection[2 * point + 1]:
                    left = selection[2 * point]
                    right = selection[2 * point + 1]
                    arr1 = [32, 64, 128]
                    arr2 = []
                    for i in range(0, len(arr1)):
                        if arr1[i] >= left and arr1[i] <= right:
                            arr2.append(arr1[i])
                    child[point] = choice(arr2)
            if point == 7:
                if selection[2 * point] != 'default':
                    child[point] = choice(['softmax', 'sigmoid', 'relu', 'tanh'])
            if point == 8:
                if selection[2 * point - 1] != 'default':
                    child[point] = choice(['adam', 'rmsprop', 'adagrad'])
            if point == 9:
                if selection[2 * point - 2] != 'default':
                    child[point] = choice(['categorical_crossentropy', 'mse', 'mae'])
    return child


def create_initial_data(selection, data):  # data is x_train,y_train,x_value,y_value
    pop_size = selection[
        17]  # pop_size is the number of for loops, indicating how many sets of data to be generated
    pop = np.empty([pop_size, 10], dtype=object)  # pop contains all the parameters to be optimized
    fitness = np.zeros([pop_size, ])  # fitness contains accuracy of LSTM model
    for i in range(0, pop_size):
        results = []
        LSTMCount = 0
        if selection[0] == selection[1]:
            LSTMCount = selection[0]
        else:
            LSTMCount = np.random.randint(selection[0], selection[1], size=1).tolist()[0]
        units1 = 0
        units2 = 0
        units3 = 0
        if LSTMCount == 1:
            if selection[2] == selection[3]:
                units1 = selection[2]
            else:
                units1 = np.random.randint(selection[2], selection[3], size=1).tolist()[0]
        elif LSTMCount == 2:
            if selection[2] == selection[3]:
                units1 = selection[2]
            else:
                units1 = np.random.randint(selection[2], selection[3], size=1).tolist()[0]

            if selection[4] == selection[5]:
                units2 = selection[4]
            else:
                units2 = np.random.randint(selection[4], selection[5], size=1).tolist()[0]

        else:
            if selection[2] == selection[3]:
                units1 = selection[2]
            else:
                units1 = np.random.randint(selection[2], selection[3], size=1).tolist()[0]

            if selection[4] == selection[5]:
                units2 = selection[4]
            else:
                units2 = np.random.randint(selection[4], selection[5], size=1).tolist()[0]

            if selection[6] == selection[7]:
                units3 = selection[6]
            else:
                units3 = np.random.randint(selection[6], selection[7], size=1).tolist()[0]

        dropoutRate = 0
        if selection[8] == selection[9]:
            dropoutRate = selection[8]
        else:
            dropoutRate = choice(np.arange(selection[8], selection[9], 0.1))

        epochs = 0
        if selection[10] == selection[11]:
            epochs = selection[10]
        else:
            epochs = np.random.randint(selection[10], selection[11], size=1).tolist()[0]

        batchSize = 0
        if selection[12] == selection[13]:
            batchSize = selection[12]
        else:
            left = selection[12]
            right = selection[13]
            arr1 = [32, 64, 128]
            arr2 = []
            for i in range(0, len(arr1)):
                if arr1[i] >= left and arr1[i] <= right:
                    arr2.append(arr1[i])
            batchSize = choice(arr2)

        denseActivation = 0
        if selection[14] == 'default':
            denseActivation = choice(['softmax', 'sigmoid', 'relu', 'tanh'])
        else:
            denseActivation = selection[14]

        optimizer = 0
        if selection[15] == 'default':
            optimizer = choice(['adam', 'rmsprop', 'adagrad'])
        else:
            optimizer = selection[15]

        loss = 0
        if selection[16] == 'default':
            loss = choice(['mse', 'mae', 'categorical_crossentropy'])
        else:
            loss = selection[16]
        results.append(LSTMCount)
        results.append(units1)
        results.append(units2)
        results.append(units3)
        results.append(dropoutRate)
        results.append(epochs)
        results.append(batchSize)
        results.append(denseActivation)
        results.append(optimizer)
        results.append(loss)
        pop[i] = results
        fitness[i] = get_fitness(results, data)
        print('第' + str(i + 1) + '个DNA')
    return pop, fitness


def load_data(path1, path2):  # Load data set
    list = []
    feature = 'feature'
    for i in range(0, 576):  # Add a name to each column of features :column='feature'+i
        column = feature + str(i)
        list.append(column)
    df = pd.read_csv(path1, names=list, header=0)
    # Training set
    DataSet = df[:11000].iloc[:, :]  # Take the first 110000 rows and all columns of data
    df1 = pd.read_csv(path2)  # Read the label of the training set
    df1.columns = ['label']  # Rename the features of the training set
    LabelSet = df1[:11000].iloc[:, :]  # Take the labels of the first 110,000 lines
    # Convert label to one-hot encoding
    Labels = to_categorical(LabelSet, num_classes=None)
    X_train, X_val, Y_train, Y_val = train_test_split(DataSet, Labels, test_size=0.3,
                                                      random_state=42)  # Turn 30% of the data set into a validation set
    x_train = X_train.values.reshape(7700, 1, 576)  # Convert DataFrame to numpy.array class and reshape
    x_val = X_val.values.reshape(3300, 1, 576)

    y_train = Y_train
    y_val = Y_val
    Shape = (1, 576)
    return Shape, x_train, y_train, x_val, y_val


def get_fitness(results, data):
    return Lstm.get_accuarcy(results, data)


def run(dna_size, pop_size, cross_rate, mutation_rate, n_generations, path1, path2, selection, threshold):
    DNA_SIZE = dna_size
    POP_SIZE = pop_size
    CROSS_RATE = cross_rate
    MUTATION_RATE = mutation_rate
    N_GENERATIONS = n_generations

    data = load_data(path1, path2)
    ret = create_initial_data(selection, data)
    pop = ret[0]
    fitness = ret[1]
    original_pop = pop
    original_finess = fitness
    print(pop)
    print(fitness)

    MAX_Index = np.argmax(fitness)  # Find the best fitness of the initial population
    MAX_DNA = pop[MAX_Index, :]

    fitness = fitness.reshape(POP_SIZE, )

    best_generation = []

    flag = 0
    dna_set = []
    for each_generation in range(N_GENERATIONS):

        pop = select(pop, fitness, POP_SIZE)  # select
        pop_copy = pop.copy()
        for parent in pop:
            child = crossover(parent, pop, CROSS_RATE, POP_SIZE, DNA_SIZE, selection)  # cross
            child = mutate(child, DNA_SIZE, MUTATION_RATE, selection)  # mulation
            parent = child
        if fitness[0] <= fitness[
            MAX_Index]:  # If the fitness of the first DNA is smaller than the maximum, then MAX_DNA is placed first
            pop[0] = MAX_DNA
        fitness = np.zeros([POP_SIZE, ])
        for i in range(POP_SIZE):
            pop_list = list(pop[i])
            fitness[i] = get_fitness(pop_list, data)
            print('第%d代第%d个染色体的适应度为%f' % (each_generation + 1, i + 1, fitness[i]))
            print('此染色体为：', pop_list)
            if fitness[i] >= threshold:
                flag = 1
                print("条件终止")
                break
        print("Generation:", each_generation + 1, "Most fitted DNA: ", pop[np.argmax(fitness), :], "适应度为：",
              fitness[np.argmax(fitness)])
        MAX_Index = np.argmax(fitness)
        MAX_DNA = pop[MAX_Index, :]
        dna_set.append(MAX_DNA)
        best_generation.append(fitness[MAX_Index])

        if flag == 1:
            break
    return best_generation, dna_set, original_pop, original_finess


def fitness_figure(best_generation):
    x = np.linspace(1, len(best_generation), len(best_generation))
    y = best_generation
    plt.plot(x, y)
    plt.xlabel("generation")
    plt.ylabel("fitness")
    plt.show()

# ==========================================test=========================================

# path1='/content/drive/MyDrive/2020WS/GA/traindata.csv'
# path2='/content/drive/MyDrive/2020WS/GA/trainlabel.csv'
# selection=[1,4,100,200,100,200,150,200,0.1,0.3,20,20,128,128,'default','default','categorical_crossentropy',30]

# threshold=0.95
# best_generation ,dna_set, original_pop, original_finess=run(10,30,0.3,0.1,7,path1,path2,selection,threshold)
# print(best_generation)
# print(dna_set)
# print(original_pop)
# print(original_finess)

# fitness_figure(best_generation)   plot the figure
