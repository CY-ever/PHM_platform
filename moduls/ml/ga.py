# -*- coding: utf-8 -*-
"""DT_GA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zR9Kihf0TdAyqxgdWGHUuwqOoDrdZzeV
"""

import tensorflow as tf
import pandas as pd
from tensorflow import keras
import matplotlib.pyplot as plt
import numpy as np
from random import choice
# from keras.utils.np_utils import to_categorical
from sklearn.model_selection import train_test_split
import sys
import os

from moduls.ml.dataset import import_data
from moduls.ml.py.Autoencoder import train_model

from moduls.ml.svm import SVM_Model


class Param:
    criterion = 'gini'
    splitter = 'best'
    max_depth = None
    min_samples_split = 2
    min_samples_leaf = 1
    min_weight_fraction_leaf = 0.0
    max_features = None
    random_state = None
    max_leaf_nodes = None
    min_impurity_decrease = 0.0
    min_impurity_split = None
    class_weight = None
    ccp_alpha = 0.0


class Option:
    sample_weight = None
    check_input = True
    X_idx_sorted = None


# Roulette Selection
def select(pop, fitness, POP_SIZE):
    print("POP_SIZE:", POP_SIZE, "fitness:", fitness)
    a = []
    for i in fitness:
        if i <= 0:
            i = 0.001
        a.append(i)
    fitness = np.array(a)
    fitness_sum = fitness.sum()
    p = fitness / fitness_sum
    print("p", type(p))
    if fitness_sum < 0.001:
        # fitness_sum = fitness = 0.001
        idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True)
    else:
        idx = np.random.choice(np.arange(POP_SIZE), size=POP_SIZE, replace=True, p=p)
    return pop[idx]


# cross
def crossover(parent, pop, CROSS_RATE, POP_SIZE, DNA_SIZE, selection):
    if np.random.rand() < CROSS_RATE:
        i_ = np.random.randint(0, POP_SIZE, size=1)  # Randomly take the index of a gene
        cross_points = np.random.randint(0, 2, size=len(parent)).astype(np.bool)  # Randomly pick intersection
        for i, point in enumerate(cross_points):
            parent[cross_points] = pop[i_, cross_points]  # Random point crossover

    return parent


# mutations
def mutate(child, DNA_SIZE, MUTATION_RATE, selection):
    for point in range(DNA_SIZE):
        if np.random.rand() < MUTATION_RATE:

            if point == 0:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(4, 20)
            if point == 1:
                if selection[2 * point] != selection[2 * point + 1]:
                    child[point] = np.random.randint(1, 12, size=1).tolist()[0]

    return child


def get_fitness(results, Model, Model_name,
                x_train=None, x_test=None, y_train=None, y_test=None,
                rul_pre=False):
    """

    :param results:
        (C=params[0], gamma=params[1])
    :param params:SVM:(C=params[0], gamma=params[1])
    :param Model: 传入的模型方法
    :return:
    """
    Param1 = Param()
    Param1.random_state = 30
    Param1.max_path = results[0]
    Param1.min_samples_leaf = results[1]
    Option1 = Option()

    # 获得模型成绩
    # score = np.random.randint(0.1, 50)
    if Model_name in ["DBN", "KNN", "ET"]:
        score = 1 - Model.get_score(results, rul_pre)[1]
    elif Model_name in ["CNN", ]:
        score = 1 - Model.cnn_get_error(results)
        if score <= 0:
            score = 0
    elif Model_name in ["LSTM", "RF", "DT"]:
        score = Model(x_train, x_test, y_train, y_test, results, rul_pre=rul_pre)[1]
        if score <= 0:
            score = 0
    elif Model_name in ["SVM", ]:
        score = 1 - Model.get_score(results)
        if score <= 0:
            score = 0
    # elif Model_name in ["RF", "DT"]:
    #     error = Model(x_train, x_test, y_train, y_test, results)
    #     score = 1 - error
    elif Model_name in ["AE", ]:
        pre, error = Model(x_train, x_test, y_train, y_test, results, rul_pre=rul_pre)
        score = 1 - error
        if score <= 0:
            score = 0
    else:
        print("没有这个选项")
        score = None
    return score


def create_initial_data(selection, Model, pop_size, Model_name,
                        x_train=None, x_test=None, y_train=None, y_test=None,
                        rul_pre=False, ):  # data is x_train,y_train,x_value,y_value
    # pop_size = selection[4]  # pop_size is the number of for loops, indicating how many sets of data to be generated
    params_num = len(selection)
    pop = np.empty([pop_size, params_num], dtype=object)  # pop contains all the parameters to be optimized
    fitness = np.zeros([pop_size, ])  # fitness contains accuracy of LSTM model
    for i in range(0, pop_size):

        # 各参数随机初始化
        results = []
        for g in range(len(selection)):
            if selection[g][0] == selection[g][1]:
                results.append(selection[g][0])
            elif isinstance(selection[g][0], int):
                results.append(np.random.randint(low=selection[g][0],
                                                 high=selection[g][1]))
            elif isinstance(selection[g][0], float):
                results.append(np.random.uniform(low=selection[g][0],
                                                 high=selection[g][1]))
            else:
                results.append(np.random.choice(selection[g]))

        print("GA初始化", results)
        pop[i] = results

        fitness[i] = get_fitness(results, Model, Model_name,
                                 x_train, x_test, y_train, y_test, rul_pre=rul_pre)
        print('第' + str(i + 1) + '个DNA')
    return pop, fitness


def fitness_figure(best_generation, net, output_image=0, save_path=None):
    """
    绘制结果图
    :param best_generation:
    :param save_path:
    :return:
    """
    x = np.linspace(1, len(best_generation), len(best_generation))
    y = best_generation
    plt.plot(x, y)
    plt.xticks(x)
    plt.xlabel("Iteration ")
    plt.ylabel("Objective costs")
    plt.title("Optimization curve")
    # file_name = net + "_ga.png"
    # file_name = "optimization_curve.png"
    if save_path:
        if output_image == 1:
            plt.savefig(os.path.join(save_path, "optimization_curve.jpg"))
        elif output_image == 2:
            plt.savefig(os.path.join(save_path, "optimization_curve.svg"))
        elif output_image == 3:
            plt.savefig(os.path.join(save_path, "optimization_curve.pdf"))
        else:
            plt.savefig(os.path.join(save_path, "optimization_curve.png"))

    else:
        # pass
        plt.show()
    plt.close()


def plot_curve(costs, net, save_path=None):
    """
    Plot optimizer curve with iteration

    :return: None
    """
    plt.plot(costs)
    plt.ylabel("Objective costs")
    plt.xlabel("Iteration")
    file_name = net + "_ga.png"
    if save_path:
        plt.savefig(os.path.join(save_path), file_name)
    else:
        plt.show()


def parameter_space(Model_name):
    selection = []
    # 优化参数范围准备
    if Model_name == "SVM":  # [C, gamma]
        selection.append([15, 100])
        selection.append([0.001, 0.01])

    if Model_name == "KNN":  # [K, weights]
        selection.append([1, 15])
        selection.append(["uniform", "distance"])

    elif Model_name == "DBN":  # [Dropout,LearningRate_RBM,LearningRate_nn]
        selection.append([0.5, 0.8])
        selection.append([1e-4, 1e-3])
        selection.append([1e-4, 1e-3])

    elif Model_name == "CNN":  # [dropout, learning rate, ]
        selection.append([0.3, 0.8])
        selection.append([0.0001, 0.02])
        selection.append([0.0, 1.0])
        selection.append([0.0, 1.0])

    elif Model_name == "LSTM":
        selection.append([1, 3])
        selection.append([210, 250])
        selection.append([160, 209])
        selection.append([100, 155])
        selection.append([20, 20])
        selection.append([128, 128])
        selection.append(['softmax', 'sigmoid', 'relu', 'tanh'])
        selection.append(['adam', 'rmsprop', 'adagrad'])
        # selection.append([0.0, 1.0])

    # LayerCount[1, 3], int
    # units1[210, 250], int
    # units2[160, 209], int
    # units3[100, 155], int
    # epochs[20, 20], int
    # batchSize[128, 128], int
    # denseActivation['softmax', 'sigmoid', 'relu', 'tanh']
    # optimizer['adam', 'rmsprop', 'adagrad']
    # loss['mse', 'mae', 'categorical_crossentropy']

    elif Model_name == "AE":  # [LayerCount, units1, units2, units3, epochs, batchSize, denseActivation, optimizer, loss]
        selection.append([1, 4])
        selection.append([210, 250])
        selection.append([160, 209])
        selection.append([100, 155])
        selection.append([20, 50])
        selection.append([128, 128])
        selection.append(['relu', 'relu'])
        selection.append(['adam', 'adam'])
        selection.append(['mse', 'mse'])

    elif Model_name in ["RF", "ET"]:  # [max_depth, max_leaf_nodes, n_estimators]
        selection.append([4, 20])
        selection.append([2, 800])
        selection.append([8, 30])

    elif Model_name == "DT":  # [max_depth, max_leaf_nodes, n_estimators]
        selection.append([4, 20])
        selection.append([2, 600])

    return selection


def run(Model, Model_name=None, var_size=None, rul_pre=False, save_path=None,
        output_image=0, threshold=100.9960, dna_size=9,
        pop_size=6,
        cross_rate=0.3, mutation_rate=0.1, n_generations=27, x_train=None, x_test=None, y_train=None, y_test=None):
    """

    :param params:SVM:(C=params[0], gamma=params[1])
    :param Model:
    :param save_path:
    :param threshold:
    :param dna_size:
    :param pop_size:2
    :param cross_rate:
    :param mutation_rate:
    :param n_generations:
    :return:
    """

    DNA_SIZE = dna_size
    POP_SIZE = pop_size
    CROSS_RATE = cross_rate
    MUTATION_RATE = mutation_rate
    N_GENERATIONS = n_generations

    # 优化参数范围准备
    # selection = parameter_space(Model_name)
    selection = var_size

    ret = create_initial_data(selection, Model, pop_size, Model_name,
                              x_train, x_test, y_train, y_test,
                              rul_pre=rul_pre)
    # pop:各迭代参数结果列表[[2,325],[2,365],[5,236]]
    # fitness:各迭代参数结果，对应的正确率、健康状况[0.5,0.6,0.7,0.8]
    # selection[4]:迭代次数
    pop = ret[0]
    fitness = ret[1]
    original_pop = pop
    original_fitness = fitness
    print(pop)
    print(fitness)
    plot_fitness = 1 - fitness
    plot_fitness.sort()
    plot_fitness = np.flipud(plot_fitness)
    # fitness = fitness.reshape(POP_SIZE, -1)
    # 将就将狂状态列表，变形为[[0.5,0.6],[0.4,0.7],...]

    MAX_Index = np.argmax(fitness)  # Find the best fitness of the initial population
    # 找到最大健康值索引
    MAX_DNA = pop[MAX_Index]
    # 根据索引找到最大健康值对应的参数[C,gamma]

    best_generation = []

    flag = 0
    dna_set = []
    for each_generation in range(N_GENERATIONS):

        # a = fitness[MAX_Index, :]
        # pop = select(pop, fitness, POP_SIZE)  # select
        pop = select(pop, fitness, len(fitness))
        pop_copy = pop.copy()
        # for parent in pop:
        #     child = crossover(parent, pop, CROSS_RATE, len(fitness), DNA_SIZE, selection)  # cross
        #     child = mutate(child, DNA_SIZE, MUTATION_RATE, selection)  # mulation
        #     parent = child

        if fitness[0] <= fitness[
            MAX_Index]:  # If the fitness of the first DNA is smaller than the maximum, then MAX_DNA is placed first
            pop[0] = MAX_DNA

        fitness = np.zeros([POP_SIZE, ])
        for i in range(POP_SIZE):
            pop_list = list(pop[i])

            # (results, params, Model)
            fitness[i] = get_fitness(pop_list, Model, Model_name,
                                     x_train, x_test, y_train, y_test,
                                     rul_pre=rul_pre)
            print('第%d代第%d个染色体的适应度为%f' % (each_generation + 1, i + 1, fitness[i]))
            print('此染色体为：', pop_list)
            if fitness[i] >= threshold:
                flag = 1
                print("条件终止")
                break
        print("Generation:", each_generation + 1, "Most fitted DNA: ", pop[np.argmax(fitness), :], "适应度为：",
              fitness[np.argmax(fitness)])
        MAX_Index = np.argmax(fitness)
        MAX_DNA = pop[MAX_Index, :]
        dna_set.append(MAX_DNA)
        # 最佳参数列表[[C,gamma],[C,gamma]]
        best_generation.append(fitness[MAX_Index])
        # 最佳健康值列表[cost1,cost2]
        if flag == 1:
            break

    fitness_figure(plot_fitness, Model_name, output_image=output_image, save_path=save_path)
    best_generation = plot_fitness[-1]
    # return best_generation, dna_set, original_pop, original_fitness
    return best_generation, dna_set

